# 0000 DP - Multidimensional

---

在 LeetCode 或其他编程挑战平台上，"DP - Multidimensional" 指的是多维动态规划（Dynamic Programming）。这种类型的动态规划通常用于解决需要两个或更多维度来存储状态的复杂问题。每一个维度代表了问题的一个不同方面或参数。

多维动态规划常见于以下情况：

1. **棋盘类问题**：如在棋盘上找到从一点到另一点的路径数量，可能需要一个二维数组来存储到达每个点的路径数。

2. **字符串问题**：比如编辑距离问题，可能需要一个二维数组来记录两个字符串的子串间的编辑距离。

3. **二维背包问题**：当你有两种不同的资源限制（例如，重量和体积）时，你可能需要一个二维数组来存储在不同重量和体积限制下的最大价值。

4. **时间序列问题**：如果你需要记录在不同时间点的不同状态，可能会使用多维数组。

5. **股票交易问题**：如最多进行 k 笔交易的最大利润问题，可能需要一个二维数组来存储到达每天不同交易次数下的最大利润。

多维动态规划的关键是正确定义状态（通常为数组中的元素）以及状态转移方程（即如何从已解决的子问题中得到当前问题的解）。状态的每一个维度通常代表了问题的一个决策点或者阶段。

例如，对于一个二维动态规划问题，状态 `dp[i][j]` 可能代表了在进行到第 `i` 个阶段时，第二个维度的参数为 `j` 时的最优解。状态转移方程将根据问题的规则定义，如 `dp[i][j]` 可能依赖于 `dp[i-1][j]`、`dp[i][j-1]` 等之前的状态。

由于状态空间的增加，多维动态规划通常比一维动态规划更复杂，也需要更多的内存空间。在设计算法时，如何优化空间和计算效率是一个重要的考虑因素。

# 0062 Unique Paths

---

**题目翻译**

62. 不同路径
有一个机器人位于一个 m x n 网格的左上角（即，网格的 [0][0] 位置）。机器人试图到达网格的右下角（即，网格的 [m - 1][n - 1] 位置）。机器人在任何时候只能向下或向右移动。

给定两个整数 m 和 n，返回机器人到达右下角可能的不同路径的数量。

测试案例保证答案不超过 2 * 10^9。

> 例子 1：
>
> 输入：m = 3, n = 7
> 输出：28

> 例子 2：
>
> 输入：m = 3, n = 2
> 输出：3
> 解释：从左上角出发，总共有 3 条不同的路径可以到达右下角：
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下

约束条件：

1 <= m, n <= 100

**涉及的知识点及解题思路**

这道题目主要涉及动态规划（DP）的知识点。机器人只能向下或向右移动，因此，到达每个位置的路径数等于它上方位置的路径数加上左方位置的路径数。我们可以用一个二维数组 dp 来存储到达每个位置的路径数，其中 dp[i][j] 表示到达位置 (i, j) 的路径数。

**解题步骤**

1. 初始化边界条件，即第一行和第一列的 dp 值都为 1，因为第一行的所有位置都只能从左边一直向右到达，第一列的所有位置都只能从上面一直向下到达。
2. 从 (1, 1) 位置开始，迭代计算每个位置的 dp 值，直到计算出 dp[m - 1][n - 1]。
3. 返回 dp[m - 1][n - 1]，即为所求的答案。

在时间和空间复杂度上，我们可以进一步优化，使用一个一维数组来代替二维数组，因为计算 dp[i][j] 时，只需要 dp[i][j-1] 和上一行的 dp[i-1][j]，所以我们可以用滚动数组的方式，只保留当前行和上一行的信息。

**Python 解法**
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 初始化 dp 数组，长度为 n，因为每次只需要上一行和当前行的数据
        dp = [1] * n
        # 从第二行第二列开始计算，因为第一行和第一列都已经初始化为1
        for i in range(1, m):
            for j in range(1, n):
                # dp[j] 表示更新当前行的第 j 个值，dp[j-1] 表示当前行前一个值，dp[j] 也代表上一行的 dp[j]，即左边和上边之和
                dp[j] += dp[j - 1]
        # 返回最后一个值，即到达右下角的路径总数
        return dp[-1]
```

这段代码的时间复杂度为 O(mn)，因为我们需要计算整个 m x n 网格。

空间复杂度优化到 O(n)，因为我们只用到了一个长度为 n 的一维数组来存储状态。

# 1143 Longest Common Subsequence

---

**题目翻译**

1143. 最长公共子序列

给定两个字符串 `text1` 和 `text2`，返回它们的最长公共子序列的长度。如果没有公共子序列，则返回 `0`。

字符串的子序列是从原始字符串生成的新字符串，可以删除一些（也可以不删除）字符，而不改变剩余字符的相对顺序。

例如，"ace" 是 "abcde" 的一个子序列。
两个字符串的公共子序列是两个字符串都有的子序列。

> 示例 1:
>
> 输入：text1 = "abcde", text2 = "ace" 
> 输出：3  
> 解释：最长公共子序列是 "ace"，长度为 3。

> 示例 2:
>
> 输入：text1 = "abc", text2 = "abc"
> 输出：3
> 解释：最长公共子序列是 "abc"，长度为 3。

> 示例 3:
>
> 输入：text1 = "abc", text2 = "def"
> 输出：0
> 解释：没有公共子序列，所以结果为 0。

约束条件：

1 <= text1.length, text2.length <= 1000
text1 和 text2 仅由小写英文字母组成。

**涉及的知识点及解题思路**

这道题目主要涉及动态规划的知识点。为了找到两个字符串的最长公共子序列，我们可以使用一个二维数组 dp，其中 dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度。

**解题步骤**

1. 初始化一个 (m+1) x (n+1) 的二维数组 dp，其中 m 和 n 分别是 text1 和 text2 的长度。因为子序列的长度可以从 0 开始，所以数组的大小要比字符串长度多 1。
2. 迭代填充 dp 数组。对于每个 i 和 j，如果 text1[i-1] == text2[j-1]，那么 dp[i][j] = dp[i-1][j-1] + 1，因为找到了一个公共字符；如果不相等，则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])，因为我们要找最长的子序列，所以取较大值。
3. 返回 dp[m][n]，即为两个字符串的最长公共子序列的长度。

**Python 解法**
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        # 初始化 dp 数组
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # 动态规划填表
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    # 如果当前字符相等，那么公共子序列长度加一
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    # 如果不相等，则取上方和左方的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        # 返回最终的最长公共子序列长度
        return dp[m][n]
```

这段代码的时间复杂度为 O(mn)，空间复杂度也为 O(mn)，因为我们需要一个二维数组来存储状态。如果需要进一步优化空间复杂度，可以使用滚动数组的技巧，将空间复杂度降低到 O(min(m, n))。

# 0714 Best Time to Buy and Sell Stock with Transaction Fee

---

**题目翻译**

714. 买卖股票的最佳时机含手续费
中等难度

给定一个数组 `prices`，其中 `prices[i]` 是第 `i` 天给定股票的价格，和一个整数 `fee` 表示交易费用。

找出你能获得的最大利润。你可以尽可能完成更多的交易，但每笔交易你都需要支付交易费用。

注意：

你不能同时参与多笔交易（即，你必须在再次购买前出售股票）。
交易费用只在每次买入和卖出股票时收取一次。

> 示例 1:
>
> 输入: prices = [1,3,2,8,4,9], fee = 2
> 输出: 8
> 解释: 最大利润可以通过以下方式实现：
> - 在价格 prices[0] = 1 时买入
> - 在价格 prices[3] = 8 时卖出
> - 在价格 prices[4] = 4 时买入
> - 在价格 prices[5] = 9 时卖出
> 总利润为 ((8 - 1) - 2) + ((9 - 4) - 2) = 8。

> 示例 2:
>
> 输入: prices = [1,3,7,5,10,3], fee = 3
> 输出: 6

约束条件：

1 <= prices.length <= 5 * 10^4
1 <= prices[i] < 5 * 10^4
0 <= fee < 5 * 10^4

**涉及的知识点及解题思路**

这道题目主要涉及动态规划的知识点。解决这个问题的关键是要跟踪两个状态，即在任何一天结束时，手里持有股票和不持有股票时的最大利润。这样，我们可以使用两个数组 `hold` 和 `notHold`，其中 `hold[i]` 表示在第 `i` 天结束时持有股票的最大利润，`notHold[i]` 表示在第 `i` 天结束时不持有股票的最大利润。

**解题步骤**

1. 初始化 `hold[0] = -prices[0]`，因为在第一天我们只能买入股票，`notHold[0] = 0`，因为开始时我们没有股票。
2. 从第二天开始，迭代更新 `hold[i]` 和 `notHold[i]`：
   - `hold[i]` 等于前一天持有股票的利润 `hold[i-1]` 和前一天不持有股票但第 `i` 天买入股票的利润 `notHold[i-1] - prices[i]` 中的较大值。
   - `notHold[i]` 等于前一天不持有股票的利润 `notHold[i-1]` 和前一天持有股票但第 `i` 天卖出股票的利润 `hold[i-1] + prices[i] - fee` 中的较大值。
3. 返回 `notHold[n-1]`，即在最后一天不持有股票时的最大利润。

**Python 解题代码**

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        # 初始化持有和不持有股票时的利润
        hold, notHold = -prices[0], 0
        
        # 遍历每一天的价格
        for price in prices[1:]:
            # 更新持有股票时的最大利润
            hold = max(hold, notHold - price)
            # 更新不持有股票时的最大利润
            notHold = max(notHold, hold + price - fee)
        
        # 返回最后一天不持有股票时的最大利润
        return notHold
```

这段代码的时间复杂度为 O(n)，空间复杂度为 O(1)，因为我们只使用了常数个变量来存储状态。这是一个时间和空间复杂度都优化得很好的解法。

# 0072 Edit Distance

---

**题目翻译**

给定两个字符串 `word1` 和 `word2`，返回将 `word1` 转换成 `word2` 所需的最小操作次数。

你可以对一个单词进行以下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

> 示例 1：
>
> 输入：word1 = "horse", word2 = "ros"
> 输出：3
> 解释：
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (移除 'r')
> rose -> ros (移除 'e')

> 示例 2：
>
> 输入：word1 = "intention", word2 = "execution"
> 输出：5
> 解释：
> intention -> inention (移除 't')
> inention -> enention (将 'i' 替换为 'e')
> enention -> exention (将 'n' 替换为 'x')
> exention -> exection (将 'n' 替换为 'c')
> exection -> execution (插入 'u')

约束条件：

- 0 <= word1.length, word2.length <= 500
- word1 和 word2 由小写英文字母组成。

**解题思路**

这是一个经典的动态规划问题，通常被称为“编辑距离”问题。解决这个问题的思路是使用一个二维数组 dp，其中 dp[i][j] 表示从 word1 的前 i 个字符转换到 word2 的前 j 个字符所需的最小操作次数。状态转移方程如下：

- 如果 word1 的第 i 个字符和 word2 的第 j 个字符相同，则 dp[i][j] = dp[i-1][j-1]。
- 否则，我们必须在插入、删除和替换操作中选择一个最小的操作次数，因此 dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])。

**Python 解法**

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # 初始化 dp 数组，+1 是为了包含空字符串的情况
        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]

        # 填充 dp 数组的边界，即一个字符串转换成空字符串的情况
        for i in range(len(word1) + 1):
            dp[i][0] = i
        for j in range(len(word2) + 1):
            dp[0][j] = j

        # 计算 dp 数组的其它值
        for i in range(1, len(word1) + 1):
            for j in range(1, len(word2) + 1):
                # 如果当前字符相等，则不需要操作，直接取左上角的值
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 否则，在三种操作中选择最小值，并加一
                    dp[i][j] = 1 + min(dp[i - 1][j],    # 删除
                                       dp[i][j - 1],    # 插入
                                       dp[i - 1][j - 1]) # 替换
        # 返回 word1 转换成 word2 所需的最小操作次数
        return dp[-1][-1]
```

在这个解法中，我们尽量减少了空间的使用，只使用了一个二维数组来存储中间结果，时间复杂度为 O(mn)，空间复杂度为 O(mn)，其中 m 和 n 分别是 word1 和 word2 的长度。

