# 0000 Intervals

----

在 LeetCode 中，当题型分类中提到 "Intervals" 时，它通常指的是与时间区间或数值区间相关的问题。这些问题涉及到一系列的开始和结束点，例如时间段、数值范围或者线段。Intervals 类型的问题通常需要处理这些区间的合并、交集、插入或区间查询等操作。

Intervals 的题目适用于以下情况：

1. **合并区间**：给定一系列区间，要求合并所有重叠的区间。
2. **插入区间**：给定一个区间列表和一个新的区间，要求插入新区间并合并任何重叠的区间。
3. **区间交集**：找出两组区间的交集部分。
4. **无重叠区间**：给定一系列区间，要求找出一个最大的集合，其中的区间互不重叠。
5. **区间覆盖问题**：检查一组区间是否完全覆盖了某个特定的区间。
6. **区间删除问题**：从一组区间中删除重叠的区间，使得剩余的区间不再重叠。
7. **会议室预订**：检查是否有足够的会议室来安排所有的会议，或找到需要的最少会议室数量。
8. **区间和查询**：对于一系列数值区间，进行范围查询以计算特定区间内所有数值的和。

解决这类问题通常需要对区间进行排序，然后使用贪心算法、扫描线算法或者使用数据结构如线段树、树状数组来优化区间的操作。这类问题在现实生活中非常常见，如日程管理、资源分配、网络带宽管理等。

# 0435 Non-overlapping Intervals

---

**题目翻译**

给你一个区间数组 `intervals`，其中 `intervals[i] = [starti, endi]`，返回你需要移除区间的最小数量，使得剩下的区间互不重叠。

> 示例 1：
>
> 输入：intervals = [[1,2],[2,3],[3,4],[1,3]]
> 输出：1
> 解释：可以移除 [1,3]，使得剩下的区间互不重叠。

> 示例 2：
>
> 输入：intervals = [[1,2],[1,2],[1,2]]
> 输出：2
> 解释：你需要移除两个 [1,2] 来使得剩下的区间互不重叠。

> 示例 3：
>
> 输入：intervals = [[1,2],[2,3]]
> 输出：0
> 解释：你不需要移除任何区间，因为它们已经互不重叠了。

约束条件：

- 1 <= intervals.length <= 10^5
- intervals[i].length == 2
- -5 * 10^4 <= starti < endi <= 5 * 10^4

**解题思路**

这个问题可以通过贪心算法解决。首先按照区间的结束时间对所有区间进行排序，然后遍历区间数组，每次选择结束时间最早的区间，并移除所有与它重叠的区间。这样做的直觉是，结束时间越早，留给其他区间的空间就越多，从而能保留更多的区间使它们互不重叠。


**Python 解法**

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        # 按照区间的结束时间进行排序
        intervals.sort(key=lambda x: x[1])
        # 移除区间的数量
        remove_count = 0
        # 记录上一次添加到序列中的区间的结束时间
        end = float('-inf')
        
        for interval in intervals:
            # 如果当前区间的开始时间小于上一个区间的结束时间，就移除它
            if interval[0] < end:
                remove_count += 1
            else:
                # 否则，更新上一个区间的结束时间为当前区间的结束时间
                end = interval[1]
        
        # 返回需要移除的区间数量
        return remove_count
```

在这个解法中，我们首先对区间进行了排序，排序的时间复杂度是 `O(n log n)`，其中 `n` 是区间的数量。然后我们进行了一次线性扫描，时间复杂度是 `O(n)`，因此总的时间复杂度是 `O(n log n)`。

空间复杂度是 O(1) 或 O(n)，这取决于排序算法的实现（某些排序算法如归并排序需要 O(n) 的空间复杂度）。在 Python 中，排序通常使用的是 Timsort 算法，它是一种混合排序算法，在最坏的情况下需要 O(n) 的额外空间。

# 0452 Minimum Number of Arrows to Burst Balloons

---

**题目翻译**

有一些球形气球贴在代表 XY 平面的平面墙上。气球由一个 2D 整数数组 `points` 表示，其中 `points[i] = [xstart, xend]` 表示一个气球的水平直径在 `xstart` 和 `xend` 之间。你不知道气球的确切 y 坐标。

箭可以从 x 轴上的不同点垂直向上（在正 y 方向）射出。如果 `xstart <= x <= xend`，则在 x 处射出的箭会击破 `xstart` 和 `xend` 的气球。可以射出无限数量的箭。射出的箭会无限地向上行进，击破其路径上的任何气球。

给定数组 `points`，返回必须射出的最小箭数以击破所有气球。

> 示例 1：
>
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]
> 输出：2
> 解释：气球可以被 2 支箭击破：
> - 在 x = 6 处射出一箭，击破气球 [2,8] 和 [1,6]。
> - 在 x = 11 处射出一箭，击破气球 [10,16] 和 [7,12]。

> 示例 2：
>
> 输入：points = [[1,2],[3,4],[5,6],[7,8]]
> 输出：4
> 解释：每个气球需要射出一箭，总共需要 4 支箭。

> 示例 3：
>
> 输入：points = [[1,2],[2,3],[3,4],[4,5]]
> 输出：2
> 解释：气球可以被 2 支箭击破：
> - 在 x = 2 处射出一箭，击破气球 [1,2] 和 [2,3]。
> - 在 x = 4 处射出一箭，击破气球 [3,4] 和 [4,5]。

约束条件：

- 1 <= points.length <= 10^5
- points[i].length == 2
- -2^31 <= xstart < xend <= 2^31 - 1

**解题思路**
这个问题可以用贪心算法来解决。首先按照气球的结束坐标对所有气球进行排序，然后遍历排序后的气球，每次尽可能晚地射出箭（即在当前未被射爆气球的最小结束坐标处射箭），这样可以保证箭射出后能射爆尽可能多的气球。

**Python 解法**

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        # 按照气球的结束坐标排序
        points.sort(key=lambda x: x[1])
        # 初始化箭数为 0
        arrows = 0
        # 初始化一个非常小的箭射出位置
        arrow_pos = float('-inf')
        
        for balloon in points:
            # 如果当前气球开始坐标大于上一箭射出位置，则需要新射出一箭
            if balloon[0] > arrow_pos:
                # 更新箭射出位置为当前气球的结束坐标
                arrow_pos = balloon[1]
                # 箭数增加
                arrows += 1
        
        # 返回最小需要的箭数
        return arrows
```

在这个解法中，我们首先对气球按照结束坐标进行了排序，排序的时间复杂度是 O(n log n)，其中 n 是气球的数量。然后我们进行了一次线性遍历，时间复杂度是 O(n)，因此总的时间复杂度是 O(n log n)。空间复杂度是 O(1)，因为除了输入数据外，我们只需要常数级别的额外空间。

