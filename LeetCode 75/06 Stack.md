# 0000 Stack

---

在编程中，特别是在 LeetCode 这类算法题目中，"Stack"（栈）是一种常用的数据结构。

**栈（Stack）的定义：**

- 栈是一种后进先出（Last In, First Out，简称 LIFO）的数据结构。
- 栈只允许在一端（通常称为“栈顶”）进行添加数据（push 操作）和移除数据（pop 操作）。

**栈的基本操作包括：**

- `push`: 将元素放入栈顶。
- `pop`: 移除栈顶元素并返回该元素。
- `peek` 或 `top`: 返回栈顶元素，但不移除它。
- `isEmpty`: 检查栈是否为空。

**栈的适用情况：**

- 栈经常用于需要“撤销”操作的场景，如编辑器的撤销功能。
- 在算法中，栈用于深度优先搜索（DFS），因为它可以帮助记住要返回的位置。
- 栈也用于解析表达式和语法（如编译器中的括号匹配），以及其他需要后进先出处理的算法。
- 栈还用于实现递归算法的非递归版本。

在 Python 中，可以用内置的列表（list）类型实现栈的所有操作，因为列表提供了在末尾添加（`append` 方法）和移除元素（`pop` 方法）的功能，这与栈的 `push` 和 `pop` 操作一致。此外，也可以使用 collections.deque，因为它在两端的添加和移除操作都是高效的。

**示例代码（使用列表作为栈）：**

```python
stack = []       # 创建空栈
stack.append(1)  # push 操作
stack.append(2)
print(stack.pop()) # pop 操作，返回 2
print(stack)       # 输出栈的当前状态，只剩下一个元素 1
```

在选择使用栈时，重要的是识别问题是否具有后进先出的特性。如果有，栈可能是解决问题的合适数据结构。

# 2390 Removing Stars From a String

---

**题目翻译：**

给定一个包含星号`*`的字符串`s`，在一次操作中，你可以：

1. 选择`s`中的一个星号。
2. 移除它左边最近的非星号字符，同时移除星号本身。
3. 返回移除所有星号后的字符串。

注意：

输入将被生成为操作总是可能的。
可以证明结果字符串总是唯一的。

例子 1：
	输入: `s = "leet**cod*e"`
	输出: `"lecoe"`
解释: 从左到右执行移除操作：

- 第1个星号最近的字符是"leet**cod*e"中的't'。s变成"lee*cod*e"。
- 第2个星号最近的字符是"lee*cod*e"中的'e'。s变成"lecod*e"。
- 第3个星号最近的字符是"lecod*e"中的'd'。s变成"lecoe"。
没有更多星号，所以我们返回"lecoe"。

例子 2：
输入: s = "erase*****"
输出: ""
解释: 整个字符串被移除，所以我们返回一个空字符串。

约束条件：

- 1 <= s.length <= 10^5
- s由小写英文字母和星号*组成。
- 上述操作可以在s上执行。

**解题思路：**

这个问题可以通过使用栈的数据结构来解决。每次遇到非星号字符，就将其推入栈中。遇到星号时，从栈中弹出一个字符。这样，栈中剩下的就是去除所有星号和相应字符后的结果。

Python代码实现：
```python
class Solution:
    def removeStars(self, s: str) -> str:
        stack = []  # 创建一个栈

        # 遍历字符串的每个字符
        for char in s:
            if char != '*':
                stack.append(char)  # 如果不是星号，就加入栈中
            else:
                stack.pop()  # 如果是星号，移除栈顶字符

        # 将栈中的字符连接成字符串返回
        return ''.join(stack)

# Example usage:
# sol = Solution()
# result = sol.removeStars("leet**cod*e")
# print(result) # This should print "lecoe"
```

时间复杂度：O(n)，其中n是字符串s的长度，我们需要遍历一次字符串。
空间复杂度：O(n)，在最坏的情况下（没有星号），我们可能需要存储整个字符串。

# 0735 Asteroid Collision

---

**题目翻译：**
这个问题是“735.小行星碰撞”问题，难度为中等。我们得到了一个整数数组`asteroids`，代表一排小行星。

对于每一个小行星，其绝对值表示其大小，符号表示其方向（正表示向右，负表示向左）。每个小行星以相同的速度移动。

找出所有碰撞后小行星的状态。如果两个小行星相遇，较小的会爆炸。如果大小相同，则两者都会爆炸。两个相同方向移动的小行星永远不会相遇。

示例 1:
输入: `asteroids = [5,10,-5]`
输出: `[5,10]`
解释: 10和-5相撞，结果是10。5和10不会相撞。

示例 2:
输入: asteroids = [8,-8]
输出: []
解释: 8和-8相撞，相互摧毁。

示例 3:
输入: asteroids = [10,2,-5]
输出: [10]
解释: 2和-5相撞，结果是-5。10和-5相撞，结果是10。

约束条件:
- 2 <= asteroids.length <= 104
- -1000 <= asteroids[i] <= 1000
- asteroids[i] != 0

**解题思路：**
这道题目的关键是要处理小行星的相互作用，尤其是不同方向上的相遇与碰撞。解决这个问题的一种有效方法是使用栈结构。

我们可以遍历`asteroids`数组，对于每个元素：
1. 如果当前小行星向右移动（正数），或者栈为空，我们直接将其推入栈中。
2. 如果当前小行星向左移动（负数），我们需要检查栈顶的小行星：
    a. 如果栈顶小行星向右移动，可能会发生碰撞。
    b. 比较栈顶小行星和当前小行星的大小：
        - 如果栈顶小行星更大，则当前小行星爆炸。
        - 如果大小相同，则两者都爆炸。
        - 如果当前小行星更大，则栈顶小行星爆炸，需要继续比较新的栈顶元素。

时间复杂度是O(n)，因为我们最多遍历一次数组，n是数组的长度。空间复杂度是O(n)，在最坏的情况下，我们可能需要一个与输入数组大小相同的栈。

下面是Python代码实现，没有使用其他import：

```python
class Solution:
    def asteroidCollision(self, asteroids):
        stack = []  # 创建一个栈来处理小行星
        for ast in asteroids:
            # 当前小行星向左移动，且栈非空，且栈顶元素向右时，可能发生碰撞
            while stack and ast < 0 < stack[-1]:
                # 比较栈顶元素和当前元素的大小
                if stack[-1] < -ast:
                    # 栈顶小行星更小，爆炸，弹出栈顶元素
                    stack.pop()
                    continue
                elif stack[-1] == -ast:
                    # 两个小行星大小相同，都爆炸，弹出栈顶元素
                    stack.pop()
                # 当前小行星爆炸，不需入栈
                break
            else:
                # 当前小行星向右移动，或者与栈顶小行星同方向，或者栈为空，直接入栈
                stack.append(ast)
        return stack
```

注意这里的`else`语句与`while`循环配合使用：仅当`while`

# 0394 Decode String

---

**题目翻译**

给定一个编码的字符串，返回它的解码字符串。

编码规则是：`k[encoded_string]`，其中方括号内的`encoded_string`恰好重复`k`次。注意，`k`保证是一个正整数。

你可以假设输入的字符串总是有效的；没有多余的空格，方括号格式正确等。此外，你可以假设原始数据不包含任何数字，数字只用于表示重复的次数`k`。例如，不会有像`3a`或`2[4]`这样的输入。

测试用例生成保证输出的长度永远不会超过`10^5`。

示例 1:
输入: s = "3[a]2[bc]"
输出: "aaabcbc"

示例 2:
输入: s = "3[a2[c]]"
输出: "accaccacc"

示例 3:
输入: s = "2[abc]3[cd]ef"
输出: "abcabccdcdcdef"

约束条件:

- 1 <= s.length <= 30
- s 由小写英文字母、数字和方括号'[]'组成。
- s 被保证是一个有效的输入。
- 所有的整数都在 [1, 300] 范围内。

**解题思路**

这个问题可以通过使用栈来解决。我们需要处理两种情况：数字和字符。遇到数字时，我们需要计算出重复的次数；遇到字符时，我们需要将其加到当前的字符串中。遇到左方括号时，我们将当前的字符串和重复次数入栈，并重置它们；遇到右方括号时，我们需要从栈中弹出重复次数和之前的字符串，并将当前字符串重复相应的次数后加到之前的字符串上。

时间复杂度是O(n)，因为我们需要遍历整个字符串，其中n是字符串的长度。空间复杂度是O(n)，因为我们在最坏的情况下可能需要一个与输入字符串大小相同的栈来保存中间结果。

以下是Python代码实现，包括详细的中文注释：

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack = []  # 创建栈保存之前的字符串和重复次数
        current_num = 0  # 当前的重复次数
        current_str = ''  # 当前的字符串
        for char in s:
            if char.isdigit():
                current_num = current_num * 10 + int(char)  # 计算重复次数
            elif char == '[':
                # 遇到左方括号，将之前的字符串和重复次数入栈，并重置
                stack.append((current_str, current_num))
                current_str, current_num = '', 0
            elif char == ']':
                # 遇到右方括号，从栈中取出字符串和重复次数
                prev_str, num = stack.pop()
                current_str = prev_str + num * current_str  # 构建重复的字符串
            else:
                current_str += char  # 构建当前的字符串
        return current_str
```

在这段代码中，我们对于字符串`s`中的每个字符进行了检查，如果是数字我们就计算重复次数，如果是字母我们就直接加到当前字符串，如果是'['我们就将之前的字符串和重复次数入栈，并重置它们为初始状态，如果是']'我们就从栈中取出一个字符串和重复次数，并将当前字符串重复相应次数后加到取出的字符串上。最后返回构建好的字符串。