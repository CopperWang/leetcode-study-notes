# 0000 Binary Search

---

在 LeetCode 或其他算法平台中，"Binary Search"（二分搜索）是一种基本的搜索算法，用于在有序的数组中快速找到一个特定元素的位置。这种算法的效率很高，因为它每一步都将搜索范围减半，所以搜索的时间复杂度是 O(log n)，其中 n 是数组的大小。

**二分搜索的工作原理是：**

1. 确定数组的中间点。
2. 比较中间点的值与目标值。
3. 如果目标值小于中间点的值，则在左侧子数组中继续搜索。
4. 如果目标值大于中间点的值，则在右侧子数组中继续搜索。
5. 如果目标值等于中间点的值，则找到了目标，返回相应的索引。
6. 如果搜索范围为空，表示找不到目标值。

**二分搜索适用的场景包括：**

- **有序数组的查找**：当数组是有序的，你想要找到一个元素是否存在于数组中，或者它的位置。
- **确定一个有界函数的极值**：例如，找到满足特定条件的最小或最大值。
- **解决一些数学问题**：例如，求解平方根或其他函数的近似值。
- **最优化问题**：在有序或部分有序的数据集中寻找最优解。

二分搜索是很多算法问题的基础部分，它经常被用作其他更复杂算法的一个组成部分。当你知道一个集合是有序的，并且需要高效地查找元素时，二分搜索是一个很好的选择。

以下是二分搜索的一个 Python 示例：

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # 如果没有找到
```

在这个例子中，函数 `binary_search` 接受一个有序数组 `arr` 和一个目标值 `target`，并返回目标值的索引或者在目标值不存在时返回 `-1`。

# 0374 Guess Number Higher or Lower

---

**题目翻译**

我们玩一个猜数字游戏。游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错时，我会告诉你我选的数字是比你猜的数字大还是小。

你可以调用一个预先定义好的 API `int guess(int num)`，它会返回三种可能的结果：

-1：你猜的数字比我选的数字大（即 num > pick）。
1：你猜的数字比我选的数字小（即 num < pick）。
0：你猜的数字正好是我选的数字（即 num == pick）。
返回我所选择的数字。

例如：

示例 1：

输入：n = 10, pick = 6
输出：6
示例 2：

输入：n = 1, pick = 1
输出：1
示例 3：

输入：n = 2, pick = 1
输出：1

限制条件：

1 <= n <= 2^31 - 1
1 <= pick <= n

**解题思路**

解题思路涉及的知识点包括二分查找。在二分查找中，我们会在一个区间内查找目标值。如果猜测结果告诉我们猜大了，我们就缩小到较小的数字范围内查找，反之，则在较大的数字范围内查找。这种方法可以让我们快速缩小搜索范围，提高查找效率。

**代码实现**

以下是使用二分查找在时间复杂度 \( O(\log n) \) 和空间复杂度 \( O(1) \) 下解决问题的 Python 代码，包括详细的中文注释：

```python
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num: int) -> int:

class Solution:
    def guessNumber(self, n: int) -> int:
        left, right = 1, n  # 初始化搜索区间为1到n
        while left <= right:  # 当左边界小于等于右边界时进行搜索
            mid = (left + right) // 2  # 计算中间值
            res = guess(mid)  # 调用API猜中间值
            if res == 0:
                return mid  # 如果猜中，返回这个数
            elif res == -1:
                right = mid - 1  # 如果猜大了，缩小到左侧区间搜索
            else:
                left = mid + 1  # 如果猜小了，缩小到右侧区间搜索
        return -1  # 如果没有找到，返回-1，实际上这行代码不会被执行，因为题目保证了一定能猜中数字
```

在这个问题中，我们通过不断地使用 `guess` API 并根据返回结果调整搜索区间的上下界，最终能够找到目标数字。由于每次猜测我们都会将搜索区间减半，所以这个算法的时间复杂度是 \( O(\log n) \)，空间复杂度是 \( O(1) \)。

# 2300 Successful Pairs of Spells and Potions

---

**题目翻译**

《2300. 成功的法术和药水对》是一道中等难度的二分查找问题。

题目给定了两个正整数数组 spells 和 potions，长度分别为 n 和 m，其中 spells[i] 代表第 i 个法术的强度，potions[j] 代表第 j 个药水的强度。

同时给定一个整数 success。一个法术和药水的配对被认为是成功的，如果它们的强度乘积至少为 success。

返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是与第 i 个法术形成成功配对的药水数量。

例如：

示例 1：

输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7
输出：[4,0,3]
解释：
- 第 0 个法术：5 * [1,2,3,4,5] = [5,10,15,20,25]。有 4 对成功。
- 第 1 个法术：1 * [1,2,3,4,5] = [1,2,3,4,5]。有 0 对成功。
- 第 2 个法术：3 * [1,2,3,4,5] = [3,6,9,12,15]。有 3 对成功。
因此，返回 [4,0,3]。
示例 2：

输入：spells = [3,1,2], potions = [8,5,8], success = 16
输出：[2,0,2]
解释：
- 第 0 个法术：3 * [8,5,8] = [24,15,24]。有 2 对成功。
- 第 1 个法术：1 * [8,5,8] = [8,5,8]。有 0 对成功。
- 第 2 个法术：2 * [8,5,8] = [16,10,16]。有 2 对成功。
因此，返回 [2,0,2]。

限制条件：

- n == spells.length
- m == potions.length
- 1 <= n, m <= 10^5
- 1 <= spells[i], potions[i] <= 10^5
- 1 <= success <= 10^10

**解题思路**

涉及的知识点包括二分查找和排序。首先，我们可以对药水强度数组进行排序，以便快速定位可以与特定法术配对成功的药水。对于每个法术，我们计算出与之成功配对的最低药水强度，然后使用二分查找来确定该强度在药水数组中的位置，从而快速计算出成功配对的数量。

以下是使用二分查找在时间复杂度 O(nlogm)（其中 n 是 spells 的长度，m 是 potions 的长度）和空间复杂度 O(1) 下解决问题的 Python 代码，包括详细的中文注释：

```python
from typing import List
from bisect import bisect_left

class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        # 首先对药水强度数组进行排序
        potions.sort()
        n = len(potions)
        result = []
        # 遍历每个法术
        for spell in spells:
            # 计算与当前法术成功配对的最低药水强度
            target = success / spell
            # 二分查找定位这个强度在药水数组中的位置
            # bisect_left 返回的是能够插入target而不破坏顺序的第一个位置
            count = n - bisect_left(potions, target)
            # 将成功配对的药水数量添加到结果列表中
            result.append(count)
        return result
```

在这个问题中，我们通过先对药水数组进行排序，然后对每个法术使用二分查找来确定成功配对的药水数量，

有效地减少了计算量。由于我们对每个法术都进行一次二分查找，所以算法的总体时间复杂度是 O(nlogm)，其中 n 是 spells 数组的长度，m 是 potions 数组的长度。空间复杂度是 O(1)，因为我们没有使用额外的存储空间。

# 0162 Find Peak Element

---

**题目**

《162. 寻找峰值》是一个中等难度的二分查找问题。

题目描述：一个峰值元素指的是它大于其相邻的元素。给你一个整数数组`nums`，数组采用 `0` 索引，找到任一峰值元素并返回其索引。数组中可能会有多个峰值，返回任意一个即可。你可以假设`nums[-1] = nums[n] = -∞`，换句话说，任何一个元素总是大于其数组外的相邻元素。你必须实现一个时间复杂度为 O(log n) 的算法来解决此问题。

例如：

示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是一个峰值元素，你的函数应该返回索引号 2。
示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：5
解释：你的函数可以返回峰值元素的索引号 1（元素 2），或索引号 5（元素 6）。

限制条件：

- 1 <= nums.length <= 1000
- -2^31 <= nums[i] <= 2^31 - 1
- nums[i] != nums[i + 1] 对所有有效的 i 都成立。

**解法**

以下是该题的 Python 解法，包括详细的中文注释，解释了其空间复杂度及时间复杂度：

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n = len(nums)  # 数组长度
        # 如果数组只有一个元素，直接返回该元素的索引
        if n == 1:
            return 0
        
        low, high = 0, n - 1  # 初始化二分查找的左右指针
        # 二分查找
        while low <= high:
            mid = low + (high - low) // 2  # 计算中点
            # 检查中点元素是否大于其相邻元素
            if mid == 0:
                if nums[mid] > nums[mid + 1]:  # 如果中点元素大于右侧元素，中点即为峰值
                    return mid
                else:
                    low = mid + 1  # 否则在右侧子数组中查找
            elif mid == n - 1:
                if nums[mid] > nums[mid - 1]:  # 如果中点元素大于左侧元素，中点即为峰值
                    return mid
                else:
                    high = mid - 1  # 否则在左侧子数组中查找
            else:
                if nums[mid] > nums[mid + 1] and nums[mid] > nums[mid - 1]:  # 中点元素大于两侧元素，即为峰值
                    return mid
                else:
                    # 如果中点元素小于右侧元素，峰值在右侧子数组中
                    if nums[mid] < nums[mid + 1]:
                        low = mid + 1
                    # 如果中点元素小于左侧元素，峰值在左侧子数组中
                    else:
                        high = mid - 1
        
        return -1  # 如果没有找到峰值，返回 -1（根据题目设定，这种情况不会发生）
```

空间复杂度：O(1) - 由于算法仅使用几个变量，所以它的空间复杂度为常量级。
时间复杂度：O(log n) - 二分查找的时间复杂度为对数级，因为在每次迭代中都将搜索区间减半。

这个解法已经是最优解法，没有更好的解法，因为任何找到峰值的算法都无法低于 O(log n) 的时间复杂度，这是由二分查找的特性决定的。

# 0875 Koko Eating Bananas

---

**题目**

《875. 猴子吃香蕉》是一个二分查找的应用问题。

题目描述：Koko 喜欢吃香蕉。有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。守卫已经离开，并将在 `h` 小时后回来。

Koko 可以决定她每小时吃香蕉的速度， `k` 根/小时。每个小时，她选择一堆香蕉并从中吃掉 `k` 根。如果那堆香蕉少于 `k` 根，她会将其全部吃掉，并且在这一小时内不再吃更多的香蕉。

Koko 喜欢慢慢吃，但她仍希望在守卫返回前吃完所有的香蕉。

返回她可以在 h 小时内吃完所有香蕉的最小整数 k。

例如：

示例 1：

输入：piles = [3,6,7,11], h = 8
输出：4
示例 2：

输入：piles = [30,11,23,4,20], h = 5
输出：30
示例 3：

输入：piles = [30,11,23,4,20], h = 6
输出：23

限制条件：

- 1 <= piles.length <= 10^4
- piles.length <= h <= 10^9
- 1 <= piles[i] <= 10^9

**解题思路**

涉及的知识点包括二分查找和数学。我们需要找到一个最小的吃香蕉速度 k，使得 Koko 能够在 h 小时内吃完所有的香蕉。我们可以使用二分查找来找到这个速度 k。定义一个检查函数 `check_can_eat` 来判断给定的 `k` 是否足够吃完所有香蕉。如果足够，则减小 `k` 的值；如果不够，则增加 `k` 的值。

以下是该题的 Python 解法，包括详细的中文注释，说明了其空间复杂度和时间复杂度：

```python
class Solution:
    def minEatingSpeed(self, piles, h):
        # 检查以速度 k 是否能在 h 小时内吃完香蕉
        def check_can_eat(k):
            actual_h = 0  # 实际需要的小时数
            for pile in piles:
                actual_h += (pile + k - 1) // k  # 向上取整来计算吃完一堆香蕉需要的小时数
            return actual_h <= h  # 如果实际需要的小时数不超过 h，返回 True

        # 初始化二分查找的左右边界
        l, r = 1, max(piles)  # 最小速度不能为 0，故从 1 开始
        # 当左右边界不相邻时进行二分查找
        while r > l:
            m = (l + r) // 2  # 计算中间速度
            # 根据检查结果调整左右边界
            if check_can_eat(m):
                r = m  # 如果以速度 m 能吃完，尝试更小的速度
            else:
                l = m + 1  # 如果不能吃完，增加速度
        return l  # 当左右边界相邻时，左边界即为结果

# 空间复杂度：O(1)，仅使用了有限的额外空间。
# 时间复杂度：O(nlogm)，其中 n 是香蕉堆的数量，m 是香蕉堆中最多香蕉的堆的数量。二分查找的时间复杂度为 O(logm)，对于每个中间速度值，我们需要 O(n) 的时间来遍历所有香蕉堆来进行检查。
```

这个解法是这个问题的最优解法，因为任何确定最小速度的算法都无法低于 O(log m) 的时间复杂度，这是由二分查找的特性决定的。在这个问题中，我们无法使用比二分查找更高效的算法来减少所需的时间复杂度。
