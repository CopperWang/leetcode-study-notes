# 0000 Monotonic Stack

---

在 LeetCode 或算法编程中，单调栈（Monotonic Stack）是一个特殊的栈结构，它主要用于解决一类特定的问题。在这个栈中，元素保持一种单调递增或递减的顺序。这种结构特别适用于处理数组中元素的下一个更大（或更小）的元素问题。

**单调栈的特点：**

1. **单调性**：栈内元素按照单调递增或递减的顺序排列。
2. **局部最优**：通过局部最优解决整体最优的问题，例如寻找数组中元素的下一个更大或更小元素。

**适用场景：**

1. **下一个更大（或更小）元素问题**：例如，给定一个数组，找出每个元素后面第一个比它大的元素。
2. **最大（或最小）矩形面积问题**：比如在直方图中找到最大的矩形。
3. **滑动窗口的最大（或最小）值问题**：使用单调队列来解决。
4. **其他需要维护一个区间最值的问题**。

**使用方法：**

单调栈的使用通常遵循以下步骤：

1. 遍历数组。
2. 对于每个元素，如果当前栈为空或者当前元素符合栈的单调性（例如，对于单调递增栈，当前元素比栈顶元素大），则将元素压入栈。
3. 如果当前元素违反了栈的单调性，不断从栈中弹出元素，直到栈为空或者栈顶元素符合单调性为止。在这个过程中，可以根据需要解决相关问题（比如更新每个被弹出元素的下一个更大元素）。
4. 继续遍历数组中的下一个元素。

**示例：**

一个典型的例子是「LeetCode 739. Daily Temperatures」问题，其中要求找出数组中每个元素后面第一个更大的元素距离当前元素的距离。这个问题就可以通过维护一个单调递减的栈来解决。

使用单调栈时，通常需要注意元素入栈和出栈的时机，以及如何在栈的帮助下获取到所需的信息。这种数据结构的优势在于它可以在一次遍历中解决问题，从而提高算法的效率。

# 0739 Daily Temperatures

---

**题目翻译**

给定一个整数数组 `temperatures` 代表每日的温度，返回一个数组 `answer`，使得 `answer[i]` 是你在第 `i` 天之后需要等待的天数，直到得到一个更高的温度。如果没有未来的某一天可能达到更高温度，则 `answer[i]` 保持为 0。

> 示例 1：
>
> 输入：temperatures = [73,74,75,71,69,72,76,73]
> 输出：[1,1,4,2,1,1,0,0]

> 示例 2：
>
> 输入：temperatures = [30,40,50,60]
> 输出：[1,1,1,0]

> 示例 3：
>
> 输入：temperatures = [30,60,90]
> 输出：[1,1,0]

约束条件：

- 1 <= temperatures.length <= 10^5
- 30 <= temperatures[i] <= 100

**解题思路**

这个问题可以通过使用栈来解决。栈用来跟踪那些尚未找到更高温度的日子。遍历温度数组时，对于每个温度，我们检查栈顶的温度是否小于当前温度。如果是，则我们找到了一个更高的温度，我们就可以计算两个温度之间的天数差，并从栈中弹出那一天。我们继续这个过程，直到栈为空或栈顶温度大于或等于当前温度。然后，我们将当前温度的索引压入栈中。

**Python 解法**

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        # 初始化答案数组，初始值为 0
        answer = [0] * len(temperatures)
        # 初始化栈，用于存储温度索引
        stack = []

        # 遍历温度数组
        for i, temp in enumerate(temperatures):
            # 检查栈不为空且当前温度大于栈顶温度
            while stack and temperatures[stack[-1]] < temp:
                # 弹出栈顶元素
                prev_day = stack.pop()
                # 计算天数差，并更新答案数组
                answer[prev_day] = i - prev_day
            # 将当前温度的索引压入栈
            stack.append(i)

        # 返回答案数组
        return answer
```

在这个解法中，我们遍历了一次温度数组，时间复杂度为 O(n)，其中 n 是温度数组的长度。空间复杂度为 O(n)，主要用于存储栈和答案数组。在最坏的情况下（即温度数组单调递减），栈的大小可以增长到与温度数组相同的长度。

# 0901 Online Stock Span

---

**题目翻译**

设计一个算法，用于收集某股票的每日价格，并返回该股票当前日的价格跨度。

股票价格的跨度是指从当天开始向后连续多少天内，股票价格小于或等于当天价格的最大天数。

例如，如果过去四天的股票价格是 [7,2,1,2]，而今天的股票价格是 2，那么今天的跨度是 4，因为从今天开始，股票价格连续 4 天小于或等于 2。同样，如果过去四天的股票价格是 [7,34,1,2]，而今天的股票价格是 8，那么今天的跨度是 3，因为从今天开始，股票价格连续 3 天小于或等于 8。

实现 StockSpanner 类：

- StockSpanner() 初始化类的对象。
- int next(int price) 给定今天的价格是 price，返回股票价格的跨度。

> 示例 1：
>
> 输入
> ["StockSpanner", "next", "next", "next", "next", "next", "next", "next"]
> [[], [100], [80], [60], [70], [60], [75], [85]]
> 输出
> [null, 1, 1, 1, 2, 1, 4, 6]

解释
StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // 返回 1
stockSpanner.next(80);  // 返回 1
stockSpanner.next(60);  // 返回 1
stockSpanner.next(70);  // 返回 2
stockSpanner.next(60);  // 返回 1
stockSpanner.next(75);  // 返回 4，因为过去 4 天的价格（包括今天的价格 75）小于或等于今天的价格。
stockSpanner.next(85);  // 返回 6

约束条件：

- 1 <= price <= 10^5
- 最多将对 next 进行 10^4 次调用。

**解题思路**

这个问题可以用栈来解决。栈中存储一对元素：价格和对应的跨度。当一个新的价格进来时，我们需要从栈中弹出所有小于或等于这个价格的元素，并累加它们的跨度，直到遇到一个更大的价格。然后将新的价格和累加后的跨度压入栈中。

**Python 解法**

```python
class StockSpanner:

    def __init__(self):
        # 初始化栈
        self.stack = []

    def next(self, price: int) -> int:
        # 初始化跨度为 1
        span = 1
        # 当栈不为空且栈顶价格小于等于当前价格时，弹出栈顶
        while self.stack and self.stack[-1][0] <= price:
            # 累加跨度
            span += self.stack.pop()[1]
        # 将当前价格和跨度压入栈
        self.stack.append((price, span))
        # 返回跨度
        return span

# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
```

在这个解法中，每个价格最多只会被压入和弹出栈一次，因此算法的时间复杂度为 O(n)，其中 n 是调用 next 方法的次数。空间复杂度为 O(n)，因为在最坏的情况下，栈可能需要存储所有的价格和跨度。