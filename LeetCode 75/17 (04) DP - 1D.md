# 0000 DP - 1D

---

在 LeetCode 的题型分类中，“DP - 1D”指的是一维动态规划（Dynamic Programming）。动态规划是一种算法思想，它通过将复杂问题分解成小问题，并存储已解决子问题的结果来避免重复计算，以此来解决优化问题。

一维动态规划通常用于解决需要线性表结构来存储状态的问题。在这种情况下，算法会使用一个一维数组（或者在一些编程语言中称为列表）来存储每个子问题的最优解。一维 DP 通常应用于以下情况：

1. **序列问题**：比如求解最长递增子序列、最大子数组和等问题，这些问题中通常只需要一个维度来记录状态。

2. **背包问题**：在 0/1 背包问题中，可以使用一维数组来优化空间复杂度，只记录当前容量下的最大价值。

3. **斐波那契数列**：计算斐波那契数列的第 N 项，可以使用一维数组来避免重复计算。

4. **路径问题**：在一个二维矩阵中计算从左上角到右下角的最短路径或最优路径时，如果每次只依赖于前一行或前一列的状态，则可以使用一维数组进行状态转移。

5. **计数问题**：如计算给定总和的硬币组合数，可以用一维数组存储达到每个总和的方式数。

一维动态规划的关键在于正确定义状态转移方程，并且确定初始化条件。这通常需要对问题有深入的理解，以及对如何将问题拆分成子问题的洞察。一旦定义了状态转移方程，就可以使用迭代的方式从基础情况开始，逐步构建出最终解决方案。

# 1137 N-th Tribonacci Number

---

**题目翻译**

题目《1137. 第 N 个泰波那契数》是一道简单难度的动态规划问题。

题目描述：泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 对于 n >= 0, Tn+3 = Tn + Tn+1 + Tn+2。

给定 n，返回 Tn 的值。

> 示例 1：
>
> 输入：n = 4
> 输出：4
> 解释：
> T_3 = 0 + 1 + 1 = 2
> T_4 = 1 + 1 + 2 = 4
> 示例 2：
>
> 输入：n = 25
> 输出：1389537

限制条件：

- 0 <= n <= 37
- 答案保证适合在一个 32 位整数内，即 answer <= 2^31 - 1。

**解题思路**

解题思路涉及到动态规划。这是一个类似于斐波那契数列的问题，但是每个数是由前三个数相加而成。我们可以用递归加记忆化的方法来减少重复计算，从而提高效率。

**Python 解法**

以下是 Python 解法，包含详细的中文注释：

```python
class Solution:
    def tribonacci(self, n: int) -> int:
        # 定义记忆化递归函数
        def memo(n, dp):
            if n <= 2:  # 基本情况
                return dp[n]
            if dp[n] != -1:  # 如果已经计算过这个值，直接返回
                return dp[n]
            # 递归计算 Tn 的值
            sm = memo(n - 3, dp) + memo(n - 2, dp) + memo(n - 1, dp)
            dp[n] = sm  # 记录计算结果
            return dp[n]
        
        if n <= 2:  # 如果 n 小于等于 2，直接返回结果
            dp = [0, 1, 1]
            return dp[n]
        dp = [-1] * (n + 1)  # 初始化动态规划数组
        dp[0], dp[1], dp[2] = 0, 1, 1  # 初始化前三个值
        return memo(n, dp)  # 计算第 n 个泰波那契数
```

空间复杂度：O(n)，动态规划数组所使用的空间。

时间复杂度：O(n)，每个 Tn 的值只计算一次，计算复杂度为线性。

这个解法已经是最优解法，因为它使用了动态规划来避免重复计算，确保每个数只被计算一次。对于这类序列问题，动态规划是一种非常高效的解法，没有更高效的方法能够减少所需的时间复杂度。

# 0746 Min Cost Climbing Stairs

---

**题目翻译**

题目《746. 使用最小花费爬楼梯》是一道一维动态规划（DP-1D）的问题。

题目描述：你将会获得一个整数数组 cost，其中 cost[i] 是你爬过第 i 个台阶的花费。一旦你支付了花费，你可以选择爬一步或者两步。

你可以选择从索引为 0 的台阶开始，或者是索引为 1 的台阶开始。

返回达到楼顶的最小花费。

> 示例 1：
>
> 输入：cost = [10,15,20]
> 输出：15
> 解释：你将从索引为 1 的台阶开始。
> - 支付 15 并爬两步到达楼顶。
> 总花费为 15。
> 示例 2：
>
> 输入：cost = [1,100,1,1,1,100,1,1,100,1]
> 输出：6
> 解释：你将从索引为 0 的台阶开始。
> - 支付 1 并爬两步到达索引 2。
> - 支付 1 并爬两步到达索引 4。
> - 支付 1 并爬两步到达索引 6。
> - 支付 1 并爬一步到达索引 7。
> - 支付 1 并爬两步到达索引 9。
> - 支付 1 并爬一步到达楼顶。
> 总花费为 6。

限制条件：

- 2 <= cost.length <= 1000
- 0 <= cost[i] <= 999

**解题思路**

解题思路涉及到动态规划。我们可以使用一维数组 dp 来存储到达每个台阶的最小花费。dp[i] 表示达到第 i 个台阶的最小花费。状态转移方程为 dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])，这表示到达第 i 个台阶的最小花费可以通过从第 i-1 或第 i-2 个台阶上来达到，并支付相应的花费。

**Python 解法**

以下是 Python 解法，包含详细的中文注释：

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        # 如果楼梯少于或等于一个台阶，则无需花费
        if n <= 1:
            return 0

        # 初始化动态规划数组，长度为 n+1，因为我们的最终目标是楼顶而不是最后一个台阶
        dp = [0] * (n + 1)

        # 从第二个台阶开始计算到达每个台阶的最小花费
        for i in range(2, n + 1):
            # 取到达当前台阶的最小花费
            dp[i] = min(cost[i - 1] + dp[i - 1], cost[i - 2] + dp[i - 2])
        
        # 返回达到楼顶的最小花费
        return dp[n]
```

空间复杂度：O(n)，动态规划数组 dp 使用了线性空间。

时间复杂度：O(n)，我们只需遍历一次 cost 数组即可计算出结果。

这个解法是最优解，因为它在保证结果正确的同时，使用了动态规划以线性时间和空间复杂度解决了问题。对于这类优化问题，动态规划是一种非常有效的方法，并且已经达到了问题的复杂度下限。

# 0198 House Robber

---

**题目翻译**

题目《198. 打家劫舍》是一道一维动态规划（DP-1D）问题。

题目描述：你是一名专业的强盗，计划沿着一条街去盗窃房屋。每个房子里都藏有一定数量的金钱，唯一阻止你盗窃每个房子的限制是相邻的房子有连通的安全系统，如果同一晚上有两个相邻的房子被闯入，系统就会自动联系警察。

给定一个表示每个房子金钱数量的整数数组 nums，返回你今晚能在不惊动警察的情况下盗窃到的最大金钱数。

> 示例 1：
>
> 输入：nums = [1,2,3,1]
> 输出：4
> 解释：盗窃第 1 个房子（金钱 = 1）然后盗窃第 3 个房子（金钱 = 3）。
> 你能盗窃到的总金额 = 1 + 3 = 4。
> 示例 2：
>
> 输入：nums = [2,7,9,3,1]
> 输出：12
> 解释：盗窃第 1 个房子（金钱 = 2），盗窃第 3 个房子（金钱 = 9）以及第 5 个房子（金钱 = 1）。
> 你能盗窃到的总金额 = 2 + 9 + 1 = 12。

限制条件：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 400

**解题思路**

解题思路涉及到动态规划。我们需要找到一种方式，可以在不触发两个相邻房子的安全系统的情况下盗取最大金额。我们可以维护一个数组，其中每个元素表示如果盗窃到当前房子为止可以获得的最大金额。

**具体解法**

以下是 Python 解法，包含详细的中文注释：

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # 如果房屋数量不超过2间，直接返回最大值
        if len(nums) <= 2:
            return max(nums)
        
        # 初始化一个记忆化数组，用来存储每一步的最优解
        memorize = [0] * len(nums)
        # 最后一个房子的最优解就是其本身的金额
        memorize[-1] = nums[-1]
        # 倒数第二个房子的最优解也是其本身的金额
        memorize[-2] = nums[-2]
        # 从倒数第三个房子开始向前遍历
        for i in range(len(nums) - 3, -1, -1):
            # 对于每一个房子，可以选择不盗窃或者盗窃
            # 如果盗窃，需要加上隔一个房子后的最优解
            memorize[i] = max(nums[i], nums[i] + max(memorize[i+2:]))
        # 第一间或第二间房子，哪个的最优解大，就选择哪个
        return max(memorize[0], memorize[1])

# 空间复杂度：O(n)，主要是记忆化数组的空间。
# 时间复杂度：O(n)，遍历了一次房子数组。
```

这个解法是最优解法，因为它利用动态规划在 O(n) 的时间内解决了问题。动态规划通过避免重复计算，确保了每个子问题只解决一次，并通过记忆化存储了每个子问题的解，从而实现了高效计算。在这类优化

# 0790 Domino and Tromino Tiling

---

**题目翻译**

题目《790. 多米诺和托米诺铺瓷砖》是一道中等难度的动态规划问题。

题目描述：你有两种类型的瓷砖：一个2x1的多米诺形状和一个托米诺形状。你可以旋转这些形状。

给定一个整数 n，返回铺满一个2x n的棋盘的方式数量。由于答案可能非常大，返回它对 10^9 + 7 取模的结果。

在铺瓷砖中，每个方格都必须被瓷砖覆盖。只有当棋盘上存在两个在4个方向上相邻的单元格，且恰好一个铺瓷砖方式占据了这两个方格时，两种铺瓷砖方式才不同。

> 示例 1：
> 输入：n = 3
> 输出：5
> 解释：五种不同的方式如上图所示。

> 示例 2： 
> 输入：n = 1
> 输出：1

限制条件：

- 1 <= n <= 1000

**解题思路**

解题思路涉及到动态规划。考虑到每一步的铺瓷砖方式会受到前几步的影响，我们可以用递归加记忆化的方法来记录之前的状态，减少重复计算。

**Python 解法**

以下是 Python 解法，包含详细的中文注释：

```python
MOD = (10**9) + 7

class Solution:
    def numTilings(self, n: int) -> int:
        memo = {}

        # 定义状态转换函数
        def state(t1, t2):
            if t1 and t2: return 3
            if t1 and not t2: return 1
            if not t1 and t2: return 2

        # 递归函数
        def recur(i, t1, t2):
            # 如果已经到达最后一列，返回1种方法
            if i == n:
                return 1
            # 如果之前已经计算过这个状态，直接返回结果
            if (i, state(t1, t2)) in memo:
                return memo[(i, state(t1, t2))]
            # 计算下一列的状态
            t3, t4 = i+1 < n, i+1 < n
            count = 0

            # 递归地计算不同状态下的铺瓷砖方法数
            if t1 and t2: count += recur(i+1, True, True)
            if t1 and t2 and t3:
                count += recur(i+1, True, False)
                count += recur(i+1, False, True)
            if t1 and not t2 and t3:
                count += recur(i+1, False, True)
            if not t1 and t2 and t4:
                count += recur(i+1, True, False)
            if not t1 and not t2:
                count += recur(i+1, True, True)
            if t1 and t2 and t3 and t4:
                count += recur(i+1, False, False)
            if t1 and not t2 and t3:
                count += recur(i+1, False, False)
            if not t1 and t2 and t3:
                count += recur(i+1, False, False)

            # 记录当前状态的结果
            memo[(i, state(t1, t2))] = count
            return count

        # 从第0列开始递归，初始状态都是True
        return recur(0, True, True) % MOD
```

空间复杂度：O(n)，递归栈空间加上记忆化存储的空间。

时间复杂度：O(n)，每个状态至多被计算一次，每次递归有限的状态转移。

这个解法已经是最优解法。

