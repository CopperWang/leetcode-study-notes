# 0000 Bit Manipulation

---

在 LeetCode 或其他算法平台上提到的 "Bit Manipulation" 指的是位运算操作。位运算是直接对整数在内存中的二进制位进行操作。位运算符包括 AND (`&`), OR (`|`), NOT (`~`), XOR (`^`), 左移 (`<<`), 及右移 (`>>`)。

位运算符是用于整数二进制表示的运算符。它们直接对整数的二进制位进行操作。以下是各位运算符的详细解释：

1. **AND (`&`)**：逐位“与”运算符。对于每对二进制位，只有当两个位都是 1 时，结果位才是 1，否则为 0。
   
   ```
   	1010
   & 1100
   --------
     1000
   ```
   
2. **OR (`|`)**：逐位“或”运算符。对于每对二进制位，如果任一位是 1，结果位就是 1，否则为 0。
   
   ```
   	1010
   | 1100
   --------
     1110
   ```
   
3. **NOT (`~`)**：逐位“非”运算符。对于二进制表示中的每一位，将 1 变为 0，将 0 变为 1。
   
   ```
   ~ 1010
   --------
   	0101 (取决于数据类型的位数，前面可能会有一系列的 1)
   ```
   
4. **XOR (`^`)**：逐位“异或”运算符。对于每对二进制位，当两个位相异（一个为 1，一个为 0）时，结果位为 1，否则为 0。
   ```
   	1010
   ^ 1100
   --------
     0110
   ```

5. **左移 (`<<`)**：二进制左移运算符。将一个数的二进制表示向左移动指定的位数，右边空出的位用 0 填充。
   ```
   	1010 << 2
   --------
   101000
   ```
   这相当于将数乘以 2 的移动位数次幂（在这个例子中是乘以 2^2 = 4）。

6. **右移 (`>>`)**：二进制右移运算符。将一个数的二进制表示向右移动指定的位数，对于有符号整数，左边通常由符号位填充（对于无符号整数，用 0 填充）。
   ```
   1010 >> 2
   --------
   0010
   ```
   这相当于将数除以 2 的移动位数次幂（在这个例子中是除以 2^2 = 4）。

**应用**

1. **性能优化**：位运算比算术运算和除法运算速度快，因为它们不涉及算术运算单元。
2. **空间优化**：使用位来表示状态可以显著减少内存的使用。
3. **特定问题解决**：某些问题自然适合使用位运算解决，比如权限控制、对二进制数的操作、密码学等。
4. **计算校验位**：在编码理论和错误检测中，使用位运算来生成校验位。
5. **解决特定算法问题**：有些算法问题，如寻找只出现一次的元素（其他元素出现两次），可以用 XOR 操作高效解决。
6. **状态压缩**：在处理子集、排列、组合等问题时，位运算可以用于表示集合状态。
7. **快速计算**：例如，用位移操作快速计算乘以 2 的幂（`n << 1` 等同于乘以 2）或除以 2 的幂（`n >> 1` 等同于除以 2）。

位运算符通常在底层编程、嵌入式系统、图形处理、网络协议分析等领域中非常常见。在算法竞赛和面试中，利用位运算解决问题可以展示出候选人对计算机运作方式和效率编程的深入理解。

# 0338 Counting Bits

---

**题目翻译**

给定一个整数 `n`，请返回一个长度为 `n + 1` 的数组 `ans`，使得对于每个 `i`（0 <= i <= n），`ans[i]` 是 `i` 的二进制表示中 `1` 的个数。

> 示例 1：
>
> 输入：n = 2
> 输出：[0,1,1]
> 解释：
> 0 --> 0
> 1 --> 1
> 2 --> 10

> 示例 2：
>
> 输入：n = 5
> 输出：[0,1,1,2,1,2]
> 解释：
> 0 --> 0
> 1 --> 1
> 2 --> 10
> 3 --> 11
> 4 --> 100
> 5 --> 101

约束条件：

- 0 <= n <= 10^5

进阶问题：

- 很容易想到一个 O(n log n) 的解法，你能否在 O(n) 的时间复杂度内解决它，并且可能只进行一次遍历？
- 你能否在不使用任何内置函数（例如 C++ 中的__builtin_popcount）的情况下做到这一点？

**解题思路**

这个问题可以通过位运算和动态规划的技巧来以 `O(n)` 的时间复杂度解决。基本思想是，对于任何数字 `x`，它的二进制表示中 `1` 的个数可以通过已知的数字 `y` 的二进制表示中 `1` 的个数来得出，其中 `y` 是 `x` 的一个子集。例如，`x` 和 `y` 的关系可以是 `y = x & (x-1)`，这样 `y` 就是 `x` 去掉最右边的 `1` 后的数字。

**Python 解法**

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        # 初始化结果数组，所有位置先置为 0
        ans = [0] * (n + 1)
        # 从 1 遍历到 n，计算每个数字的二进制中 1 的个数
        for i in range(1, n + 1):
            # i 的二进制中 1 的个数等于 i & (i-1) 的 1 个数加 1
            # i & (i-1) 的作用是去除 i 二进制表示的最右边的一个 1
            ans[i] = ans[i & (i - 1)] + 1
        # 返回结果数组
        return ans
```

在这段代码中，我们使用了一个数组来存储从 0 到 n 每个数字二进制表示中 1 的个数。通过动态规划的方式，每次计算利用了 i & (i - 1) 的结果，这样可以保证时间复杂度为 O(n)。因为数组中的每个值只计算一次，所以这也满足了一次遍历的要求。空间复杂度是 O(n)，因为我们存储了 n + 1 个结果。

# 0136 Single Number

---

**题目翻译**

给定一个非空整数数组 `nums`，除了一个元素只出现一次外，其余每个元素均出现两次。找出那个只出现一次的元素。

你必须实现一个时间复杂度为线性的解决方案，并且只使用常数额外空间。

> 示例 1：
>
> 输入：nums = [2,2,1]
> 输出：1

> 示例 2：
>
> 输入：nums = [4,1,2,1,2]
> 输出：4

> 示例 3：
>
> 输入：nums = [1]
> 输出：1

约束条件：

- 1 <= nums.length <= 3 * 10^4
- -3 * 10^4 <= nums[i] <= 3 * 10^4
- 数组中的每个元素都出现两次，除了一个元素之外，它只出现一次。

**解题思路**

这个问题可以用位操作中的异或运算来解决。异或运算有一个特性：任何数和 0 做异或运算，结果仍然是原来的数，即 `a ^ 0 = a`。而任何数和其自身做异或运算，结果是 0，即 `a ^ a = 0`。此外，异或运算满足交换律和结合律，即 `a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`。

因此，我们可以通过异或运算，对数组中的所有数字进行折叠，最终得到的结果就是只出现一次的那个数字。

**Python 解法**

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 初始化一个变量来进行异或运算，起始值为 0
        single = 0
        # 对数组中的每个数进行异或运算
        for num in nums:
            single ^= num
        # 最终 single 存储的就是只出现一次的数字
        return single
```

在这段代码中，`single` 用于通过异或运算累计结果。由于数组中除了一个数字以外，其他数字都是成对出现的，所以成对的数字会通过异或运算抵消掉，最后剩下的就是那个只出现一次的数字。这个算法的时间复杂度是 O(n)，空间复杂度是 O(1)，满足题目的要求。

# 1318 Minimum Flips to Make a OR b Equal to c

---

**题目翻译**

给定三个正整数 `a`，`b` 和 `c`。返回使得 (`a OR b == c`) 成立的情况下，`a` 和 `b` 的某些位需要翻转的最小次数。（这里的 `OR` 指的是位或运算。）

翻转操作包括在它们的二进制表示中将任何单个位的 `1` 改为 `0` 或将位 `0` 改为 `1`。

> 示例 1：
>
> 输入：a = 2, b = 6, c = 5
> 输出：3
> 解释：翻转后 a = 1, b = 4, c = 5 使得 (a OR b == c)

> 示例 2：
>
> 输入：a = 4, b = 2, c = 7
> 输出：1

> 示例 3：
>
> 输入：a = 1, b = 2, c = 3
> 输出：0

约束条件：

- 1 <= a <= 10^9
- 1 <= b <= 10^9
- 1 <= c <= 10^9

**解题思路**

要解决这个问题，我们可以对 `a`，`b` 和 `c` 的每一个二进制位进行比较。我们知道，对于位或运算来说，如果 `c` 的某一位是 `0`，那么为了满足 `a OR b == c`，`a` 和 `b` 在这一位上都必须是 `0`。如果 `c` 的某一位是 `1`，那么 `a` 和 `b` 至少有一个在这一位上是 `1`。基于这个逻辑，我们可以遍历 a，b 和 c 的每一位，根据它们之间的关系来决定是否需要翻转，以及翻转哪一个数。

**Python 解法**

```python
class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        # 初始化翻转次数为 0
        flips = 0
        # 遍历 a, b, c 的每一位，直到它们都变为 0
        while a > 0 or b > 0 or c > 0:
            # 检查 a, b, c 最右一位
            bit_a = a & 1
            bit_b = b & 1
            bit_c = c & 1

            # 如果 c 的当前位是 0，a 和 b 的当前位都应该为 0
            if bit_c == 0:
                flips += bit_a + bit_b
            # 如果 c 的当前位是 1，a 和 b 中至少有一个位应该为 1
            else:
                # 如果 a 和 b 的当前位都是 0，则翻转次数加 1
                if bit_a == 0 and bit_b == 0:
                    flips += 1

            # 右移 a, b, c 准备检查下一位
            a >>= 1
            b >>= 1
            c >>= 1

        # 返回总的翻转次数
        return flips
```

在这个解法中，我们使用了位运算来检查和翻转每一位。由于每次迭代我们都会移除 a，b，c 的最低位，直到它们全部变为 0，所以我们会访问每个数的每一位恰好一次，这意味着时间复杂度是 O(log(max(a,b,c)))。由于我们不需要额外存储空间，空间复杂度是 O(1)。尽管题目中给出的最大数字是 10^9，所以实际的时间复杂度是 O(30)，这对于常数时间复杂度的算法来说是可以接受的。

