# 458. Poor Pigs

题干：

有 `buckets` 个液体的桶，其中恰好有一个桶是有毒的。为了找出哪个是有毒的，你可以喂一些（可怜的）猪这个液体，以观察它们是否会死亡。不幸的是，你只有 `minutesToTest` 分钟的时间来确定哪个桶是有毒的。

你可以按照以下步骤喂猪：

1. 选择一些还活着的猪进行喂食。
2. 对于每一头猪，选择要喂它的桶。猪会同时消耗所有选定的桶，这不需要任何时间。每只猪都可以从任意数量的桶中饮食，而每个桶都可以被任意数量的猪饮食。
3. 等待 `minutesToDie` 分钟。在此期间，你不可以喂其他的猪。
4. 在 `minutesToDie` 分钟过后，任何喝了有毒桶里的液体的猪都会死亡，其他的都会存活下来。
5. 重复此过程，直到你用完了所有时间。

给定 `buckets`、`minutesToDie` 和 `minutesToTest`，返回在规定时间内确定哪个桶有毒所需的最小猪的数量。

分析：

这个问题实际上是一个关于信息编码的问题。考虑以下场景：如果我们只有1只猪和15分钟的时间，而且猪在吃毒草后15分钟会死，那么我们只能测试2桶。这是因为我们可以让猪吃第一桶，然后等待15分钟。如果它死了，第一桶是有毒的，否则第二桶是有毒的。

现在，考虑我们有2只猪和30分钟的时间。我们可以测试4桶。首先，让第一只猪吃第1和第2桶，让第二只猪吃第2和第3桶。如果只有第一只猪死了，那么第1桶是有毒的；如果只有第二只猪死了，那么第3桶是有毒的；如果两只猪都死了，那么第2桶是有毒的；如果都没死，那么第4桶是有毒的。

当我们可以测试的次数增加时，我们可以测试更多的桶。对于给定的`minutesToTest`和`minutesToDie`，我们可以测试的次数是`minutesToTest // minutesToDie`。

策略是将桶编码为基数为`(minutesToTest // minutesToDie + 1)`的数字。例如，如果`minutesToTest // minutesToDie`是2（意味着我们可以测试3次），那么我们可以使用3作为基数来编码桶。

每只猪可以用来确定编码的一个数字。因此，我们的目标是找到最少的猪，使得给定的基数下的编码可以涵盖所有的桶。

例如，考虑`buckets = 1000`。如果我们只可以测试一次，那么我们需要10只猪，因为2^10 = 1024。但是，如果我们可以测试两次，那么我们只需要5只猪，因为3^5 = 243（而这不够）。我们需要6只猪，因为3^6 = 729。如果我们可以测试三次，那么4^3 = 64，这还不够。但是，4^4 = 256，所以我们需要4只猪。

以下是相应的Python代码：

```python
class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        pigs = 0
        base = minutesToTest // minutesToDie + 1
        
        while (base ** pigs) < buckets:
            pigs += 1
            
        return pigs
```

时间复杂度：O(log buckets) —— 实际上是确定需要多少只猪的时间。

空间复杂度：O(1)。